# if和while的反过来
## unless    反过来的if
unless（....... )   就和   if( !....  )一样

unless里面的条件是 假时候才执行， if是真才执行

有了他们两个就可以说代码风格了
如果  两个分支，其中一个 比较短， 就要把 短的放在代码前面，这样利于维护
可以通过  ++if  和  unless 的选择，对调 两个分支的代码顺序++


## until   反过来的while
until是条件为假的时候就执行， 直到条件为真

until(......)   就和  while(  !.........)一样

同样考虑到风格需要


# 表达式修饰符

```perl
print "$n is a negative number.\n" if $n < 0;    #这就是表达式控制符，相当于一个 if语句， 跟在 某个语句后面
if( $n < 0){          #和上面一样的意思
    print #...............;
}
```

还有更多版本

```perl
&error("Invalid input") unless &valid($input);  #一直调用&error() 直到 &valid($input)  的返回值满足unless 不循环的条件 
$i *= 2 until $i > $j;
print " ", ($n += 2) while $n < 10;
&greet($_) foreach @person;    #只能通过$_ 访问值， 不能用传统的 传递变量 
```

* 第三个

```perl
while($n<10){    #条件判断在先， 也就是有可能一次循环都不执行
    print (" ",($n +=2 ));  #print的逗号就是 输出多个数据意思， $n 会先加上2，再输出
}
```

* 第四个

```perl
foreach (@person){   #条件在前面
    &greet($_);   #哪怕是风骚写法， 依然可以用 $_,但是 简写不能用传统的赋值 变量
}
```

一般 修饰符 （也就是上面红色哪些） 左右两边都**只能接受  一个 语句**
如果 修饰符左边要多个语句   或者  右边要多个 条件嵌套，  还是用回传统方法吧


这种用法一般是 用来插入  调试程序使用的

比如 到某些地方要输出 某些测试值：

```perl
print "fred = $fred, barney = $barney\n" if $TRACING   #TRACING可以在执行命令的时候 用 constant 指定全局变量
#这样只要调试程序时候 加入这个变量，就可以看到输出，反之不输出
```


# 裸块控制结构
裸块( naked block )  没有关键字或者条件表达式的代码块

一个大括号括住就是一个裸块
```
{
    .........
}
```
在裸块里面 用`my`声明的变量 只能在 块里面生效，离开了块就失效
这样保证了可维护性

```perl
{
    print "Please enter a number: ";
    chomp( my $n = <STDIN> );
    my $root = sqrt $n;   #sqrt 平方根计算函数
    print "square root of $n is $root.\n";
}
$root   $n只能在  大括号里面使用，出去就没用了
```

# `elsif ==else if`
没必要多说，只是 小心   少了个e

**perl没有switch**


# `$n++  $n--  ++$n  --$n`
就和C语言一样

```perl
$m = $n++;  #先赋值  后++
$m = ++$n;  #先++后赋值
```

有个例子有点意思

计算人名出现的次数

```perl
my @people = qw/aaa  bbb ccc aaa ggg hhh bbb  iii ggg/
my %seen;

foreach( @people)
    print "I've seen you ,$_.\n" if (%seen{$_}++);
}
```

这个代码   `if( %seen{$_}++ )`

`if`判断是在`++` 之前的，如果第一次时候 `%seen{$_}`是`undef`（比`++`操作优先）
判断结果为假 不输出
  但是 依然会执行`++`操作，下次就不是 undef了

# for循环
和C语言类似

```perl
for($i = 1; $i < 5; $i++){
    ..........
}

for(;;) {.....}   #for的无限循环（和C语言一样可以省略3个东西，但是要保留分号）
while(1) {.......}  #上面的等价， 不过推荐这种， 比较直观

for($_ = "bedrock"; s/(.)//;) {........}  #由于正则表达式可以返回布尔值，所以可以作为for的循环控制条件使用
```


for 和 foreach 是同一种东西， 编译器根据 分号来区分 **严格模式下不能互用**

这也是为什么for循环不能省略分号的原因
`for(1..5)  #等同 foreach(1..5)`  因为没有分号 



# 循环控制
和C一样 有类似的`break`，`continue`的语句，但是 不是这些单词

`last`   ==  C的`break`
遇到last就直接跳出循环，但是只能跳出一层
也就是这个语句的那一层
甚至可以跳出   ++裸 块++

```perl
next == C的continue
while(<>) {
      foreach (split) {         #句子拆分
               $total++;
               next if /\W/;        #非字符就next 字符就统计
               $value++;
               $count{$_}++;
       }
}
```


# redo  重新本次循环
强制回到块的开始

和`next`区别是  redo不会进入下个循环

而是重新开始本次循环

`next`是直接开始下次循环



# 带标签的块
块是可以有名字的，为了方便后面的管理

为了避免混淆，  块名字要全大写  

```perl
NAME:  {			#为这个块定义标签，标签名加冒号，后面 跟着括号，开始一个块
...........
}


LINE: while(<>) {				# 如果是循环的块， 那就加在 循环词前面
foreach(split) {
last LINE if /__END__/;		            #跳出LINE的循环，如果不加就是跳出本层循环（foreach），加了就是跳出 对应块的循环（while）
    ｝						# __END__ 记号代表输入结束，是指当 <> 读到 __END__时候就执行        last，  这里可以看作 普通的 字符串
｝
```

标签可以被  redo next last 使用

 一般标签 都是靠左 写， 哪怕被缩进很深，也要靠左
这个和C语言的goto 区别就是 goto标签表示代码的某一个位置
Perl的 标签 表示 一个代码块



# 条件操作符  `?: ` 
具体和C语言一样

```perl
$max = $a>$b? $a : $b;		#很标准的用法
$avg = $n  ?  ($total/$n) : '----'	# 冒号两边的表达式 是 先执行 后返回
# 也就是说 冒号两边的表达式 是可以 进行运算操作，最后结果返回 的
 
my $size = 
($width < 0) ? "small"   :
($width <20) ? "medium" :
($width <50) ? "large" :
"extra-large";

#嵌套使用 ?:	代码风骚，而且可以做类似 switch的事情   
```


# 逻辑操作符 ` && ||   //`
这里和C语言差不多，
但是还有进阶的用法

```
if( ..... && ........) {.....}		#标准用法
if(.......||........){..........}
```

## 短路操作，C语言也有
* 对于&& 要求两边都是 真， 但是Perl会从左往右检索
* 当左边为假的时候，将不再进行右边操作
* 同样对于 || 要求两边有一边是真， 
* 如果左边为真， 将不会执行右边操作

使用技巧：

```perl
if ( ($n!=0) && ($total/$n < 5) ){		#当$n!=0 不满足时候，将会不执行 $total/$n操作， 避免除以0报错
print "average is below 5\n";
}
```

### Perl强化的 短路操作
* C语言里面 短路操作 就和 一般的 && 操作一样，只能返回布尔值
* Perl里面 的返回值 是 最后一次执行的结果( 就和 Perl的子程序一样）

```perl
my $last_name = $last_name{someone} || '(No last name)' ; 		# 如果前面是假 那就返回后面的默认值，前面是真，就返回前面
#可以当做 赋予默认值操作，  但是有缺陷， 下面讲
```

## 定义或操作符 `//`
Perl 5.010 引入了定义或 操作 符号  `//`

一个变量， 如果已经有值，就不管他，  如果没有定义它的值，就赋给他一个默认值
前面的  `||` 操作 可以满足一般情况，
 但是  如果 `$last_name{someone}` 的值 是 `0` 会被当做假值处理，从而被洗掉 正确的值

`//`   操作符就不会发生这种问题， 哪怕 `$last_name{someone}`的值是 0  也可以被处理

```perl
my $last_name = $last_name{someone} // '(No last name)' ; 
```

`//`操作符 只有 检测到 `undef`时候才会返回 假， `0 `和 `'0' `都不会返回假

```perl
my $name;
print $name // '';			#在 -w 模式下，输出没初始化的变量，这样就不会 warming了
```

# 上面 骚起来 部分操作符
`&&  ||  //  ?:`

* 这些操作符都会根据左边  决定是否执行右边
* 而且 两边都可以是 运算操作
* 但是本身的返回值可以不使用
* 
于是可以骚一波

```perl
($m<$n)   &&   ($m=$n);		#不清楚优先级， 先加括号
if( $m<$n) {  $m = $n };			#上面的等价
$m = $n if  $m<$n;				#上面的等价	

($m < $n)  ?  ($m = $x) : ($n = $x);		#把 $x 赋值给 比较小的那个
```


上面的括号有点多，那是因为 `&& || // ?:` 还是有一定优先级的

```
&&  == and
|| == or
```
and 和or 的优先级就相当低了， 这样就可以 保证 不会搞错
```
$m < $n   and   $m = $n;
open my $fh,'<',$filename;
or die "Can't open '$filename' : $!";		#打开文件的习惯写法， 如果不用autodie的话
```