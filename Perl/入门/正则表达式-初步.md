# 正则表达式
> 在perl里面也叫 模式( pattern )

优先级：
1. 括号-> 分组或捕获		`(.....),   (?.....),  (?<LABEL>......)`
2. 量词					`a*,   a+   a?   a{n,m}`
3. 锚位和序列				`abc,  ^,  $,   \A   \b  \z   \Z`
4. 选择竖线				`a|b|c`
5. 原子					`a,  [abc], \d,  \1,   \g{2}`


## 简单模式（简单正则表达式）
如果正则匹配的对象是 `$_` 的内容， 直接 放到  `/    /`	里面就可以了
这就叫简单匹配

```perl
$_ = "fawe aafawe";
if( /aafa/ ) { ... }		#条件返回是真， 因为 $_ 里面包含了子串 aafa
```

## Unicode属性匹配
Unicode字符可以理解自身含义（编码时候根据分类编在一起）。完整的 Unicode 属性在 perluniprops文档中。

```perl
\p{Space}		# 匹配一个 空白字符 （26个）
\p{Digit}		# 匹配一个 数字字符	（411个）
\p{Hex}     # 匹配一个 一个16进制的字符  0~9 a~f A~F

\P{Space}		# 匹配不包含空白字符  大写P是不包含（也就是一个也不能包含）
```

## 通配符
`.`			通配任意一个字符 换行号 \n 除外

```perl  
/bar.y/		#可以被 bar=y   barty   bar2y     匹配，. 是通配符
```

+ 如果需要单纯 匹配 .  符号，  只需要转义   `\.`	就可以   
+ 同样的 `\`  也是  `\\`  	转义

**需要转义的字符叫元字符**

## 简单量词

### `*` 匹配前面的条目零次或多次

```perl
/fred\t*barney/		# 可以匹配 fred 和barney中间任意多个\t		包括没有
                  #配合.  就可以实现任意字符通配
/fred.*barney/			# 匹配所有 包含 fred 在前面  barney 在后面的 情况
                    #包括 fredbarney
```
### `+` 前面的条目 至少一个

```perl
/fred +barney/			#不会匹配到fredbarney， （空格不属于元字符 ）
```

会匹配fred   barney（中间至少一个空格）

### `?` 前面条目 一个或者没有

```perl
/ban-?ban/		#匹配 ban-ban  或 banban（一个- 或者没有 -）
```


## 通用量词`{ n,m }`

如果简单量词不够用，可以用通用量词

```perl
/a{5,15}/				#意思就是匹配 a重复5到15次   aaa 都不算匹配
/a{4,}/				#省略上限的意思就是最少4次 多了随意
/a{8}/				#只写一个数字表示要正好8次才能匹配
```


# 模式分组

## 括号运算
`( )` 把字符串看作整体来和量词运算， 括号也是元字符

```perl
/fred+/		#匹配 freddddd
/(fred)+/		#匹配 fredfredfredfred

/(fred)*/		#任何字符串都能匹配  因为  如果 fred出现0次。。。。
```

## 捕获组，反向引用
> *capture ， back reference*

括号里面的东西可以看作一个**组**,通过**反引用**来表示**组**,这个行为叫**捕获组**

其实就是**把匹配到的内容重复使用**

```perl
\1			#表示第一个 括号 里面的的东西， \2表示第二个括号的东西
/(.)\1/		# 表示 匹配是否有两个  挨着的重复字符  
/(.)		#匹配任意一个字符
 \1		#后面紧跟着刚才匹配的东西（第一个）
/		#  可以匹配  adffdfa 只要有两个相同的连在一起都可以
#这种写法只是分析用的  写法不正确

$_ = "yabba dabba doo";
if ( /y(....) d\1/ ){.....}
#反引用不一定要 紧跟在括号后面，可以有空格

$_ = "yabba dabba doo";
if ( /y(.)(.)\2\1/ ) {.....}		#匹配 abba  () 的反引用 由先到后 \1 \2 \3（按左括号的先后）

$_ = "yabba dabba doo";
if ( /y((.)(.)\3\2) d\1/) {..}		#括号嵌套不要乱， 按照左括号 算\1 \2 \3,
#这里\1 通配为 abba，

/(.)\111/			#没有\111引用，实际是想匹配 两个重复字符后面跟着11
                #当反引用后面紧跟数字时候，会按照尽可能取最大的数字处理
/(.)\g{1}11/		#通过 \g{1}	来替代 \1 可以防止这种问题

/(.)(.)\g{-1}11/		#如果\g{N} 里面的N是负数，指的是反向引用
                    #反向引用是 相对\g{N} 	这个条目往前数的个数
                    #相对 引用 维护起来方便
```

## 选择匹配 `|`

用法类似C语言的条件运算

```perl
/fred|barney|betty/		#匹配任何含有 fred 或 barney 或 betty的

/fred( |\t)+barney/		#匹配  fred ，barney  中间 有任意空格或\t  （最少有一个）
# 空格和\t可以混合出现，  +号相当于每次 加 ( |\t)   并没有指定只能是一个

/AandB|AorB/			#不推荐这种 太长会让速度下降
/A(and|or)B/			#这样效率高
```

## 字符集

可以自定义字符集，写在方括号里面，前面加上`^`符号表示不包含的意思

```perl
[a b c w x yz]			#匹配括号内任意字符，    只能匹配一个
[a-c w-z]				#和上面一样 -  指的是 从谁到谁
[a-z A-Z]				#一般是这么用，用在经典字符集， 可以匹配 不区分大小写任意英文字母

[\000-\177]			#匹配 ASCII码  000到177（通过\转义）

[^a b c]				#匹配 a b c 意外的字符（开始加上^ 就是匹配 不包含括号内容的 字符）
[^n \- z]				#匹配  n  -  z 以外的字符   -  ^  \  都要用\转义
```


## 字符集简写

```perl
\d			#数字字符集， 以前就是 [0-9]	现在包括其他语言数字字符集也算
#通过修饰符  a 解决 ASCII 和 Unicode的差别（后面会详细讲）

$_ = 'HAL-900 darpon'
if(/HAL-\d+/){ ...}		#新版本匹配
if(/HAL-\d+/a)	{....}		#按照老的ASCII码匹配

\s			#匹配 任意空白符，  大概和Unicode属性的 \p{Space}差不多（但不是一样）
#在老版本 只能匹配 [\f \t \n \r]
#Unicode 的\s	 也不会匹配 垂直制表， 下一行， 不间断的空白符
if( /\s/a )		#通过 a修饰符 使用老的 ASCII 匹配模式

\h			#只匹配水平空白
\v			#只匹配垂直空白
[\h \v]		#两个加起来就是  \p{Space}  比 \s 匹配的更多

\R			#匹配任何一个断行符，无论是windows doc unix linux 的都可以
#不用考虑系统语言风格差异

\w			#匹配一个单词  ASCII下是  [a-z A-Z 0-9 _]  (包括下划线）
#Unicode下会匹配很多	在以后的 单词边界中 详细讲

#如果需要 反匹配  只要把单词大写就可以了    \R 你别闹
/[\d A-F a-f]+/		#匹配16进制的数，  和  /\p{Hex}+/ 一样
#简写可以 作为字符集 [ ]	里面的元素


[\d \D]		#匹配 数字， 非数字，  意思就是所有都匹配
# 比 .   强一点， 那就是匹配换行符

[^\d \D]		#不匹配数字， 不匹配非数字， 那就是什么都不匹配
#无用字符集
```
